import numpy as np

from Cell import Cell
from CellStates import CellStates
from Parameters import Parameters

# Define parameters
parameters = Parameters(beta1=0.2, beta2=0.1, gamma=0.3, epsilon1=0.05, epsilon2=0.1)

# Initialize grid with Cell objects
L = 10  # Grid size
grid = np.array([[Cell(CellStates.SUSCEPTIBLE) for _ in range(L)] for _ in range(L)])


# Function to get neighbors of a cell
def get_neighbors(x, y):
    neighbors = []
    for dx in [-1, 0, 1]:
        for dy in [-1, 0, 1]:
            if dx == 0 and dy == 0:
                continue
            new_x = (x + dx) % L
            new_y = (y + dy) % L
            neighbors.append(grid[new_x, new_y])
    return neighbors


# Simulation loop
num_time_steps = 100
for _ in range(num_time_steps):
    new_grid = grid.copy()

    for x in range(L):
        for y in range(L):
            cell = grid[x, y]
            cell_state = cell.state

            # Get neighboring cell states
            neighbors = get_neighbors(x, y)
            neighbor_states = [neighbor.state for neighbor in neighbors]

            # Apply transition to the cell
            cell.transition(neighbor_states, parameters)

    grid = new_grid

# Print the final grid
for row in grid:
    print(" ".join(map(str, row)))