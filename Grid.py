import numpy as np
import matplotlib.pyplot as plt

from Cell import Cell
from CellStates import CellStates


class Grid:
    """
    A class representing the grid of cells in the cellular automation model.
    """

    def __init__(self, size, parameters, costs):
        """
        Initialize a Grid object with the given size and parameters.

        Args:
            size (int): The size of the grid (L).
            parameters (Parameters): An instance of the Parameters class containing model parameters.
            costs (Costs): An instance of the Costs class containing costs for cell states and transitions.
        """
        self.size = size
        self.parameters = parameters
        self.costs = costs
        self.grid = np.array([[Cell(CellStates.SUSCEPTIBLE) for _ in range(size)] for _ in range(size)])
        self.total_cost = 0.0  # Initialize total operating cost

    def get_neighbors(self, x, y):
        """
        Get neighboring cells of a given cell.

        Args:
            x (int): X-coordinate of the cell.
            y (int): Y-coordinate of the cell.

        Returns:
            list[Cell]: List of neighboring cells.
        """
        neighbors = []
        for dx in [-1, 0, 1]:
            for dy in [-1, 0, 1]:
                if dx == 0 and dy == 0:
                    continue
                new_x = (x + dx) % self.size
                new_y = (y + dy) % self.size
                neighbors.append(self.grid[new_x, new_y])
        return neighbors

    def simulate(self, num_time_steps):
        """
        Simulate the SASIR model for the specified number of time steps.

        Args:
            num_time_steps (int): Number of time steps to simulate.
        """
        for _ in range(num_time_steps):
            new_grid = self.grid.copy()

            for x in range(self.size):
                for y in range(self.size):
                    cell = self.grid[x, y]
                    cell_state = cell.state

                    # Get neighboring cell states
                    neighbors = self.get_neighbors(x, y)
                    neighbor_states = [neighbor.state for neighbor in neighbors]

                    # Apply transition to the cell and calculate cost
                    new_cell_state = cell.transition(neighbor_states, self.parameters)
                    # new_grid[x, y].state = new_cell_state
                    self.total_cost += self.costs.get_state_cost(new_cell_state)

                    # Calculate the cost associated with the transition
                    try:
                        self.total_cost += self.costs.get_transition_cost(cell_state, new_cell_state)
                    except:
                        self.total_cost += 0.0  # There was no effective transition

            self.grid = new_grid

    def plot(self):
        """
        Plot the current state of the grid using a grid of squares with custom colors and borders.
        """
        state_colors = {
            CellStates.SUSCEPTIBLE: 'cyan',
            CellStates.ALERT_A1: 'yellow',
            CellStates.ALERT_A2: 'orange',
            CellStates.INFECTED: 'red',
            CellStates.RECOVERED: 'green'
        }

        # Create a new figure
        fig, ax = plt.subplots()

        # Plot each cell as a colored square with thick black border
        for x in range(self.size):
            for y in range(self.size):
                cell_state = self.grid[x, y].state
                cell_color = state_colors[cell_state]
                rect = plt.Rectangle((y, x), 1, 1, color=cell_color, edgecolor='black', linewidth=2)
                ax.add_patch(rect)

        # Customize plot appearance
        plt.title("SASIR Model Simulation")
        plt.xticks(range(self.size))
        plt.yticks(range(self.size))
        plt.gca().invert_yaxis()  # Invert y-axis to match array indexing

        # Add legend
        legend_labels = ['Susceptible', 'Alert (A1)', 'Alert (A2)', 'Infected', 'Recovered']
        legend_patches = [plt.Rectangle((0, 0), 1, 1, color=state_colors[i]) for i in range(len(legend_labels))]
        plt.legend(legend_patches, legend_labels, loc='upper right', bbox_to_anchor=(1, 1))

        # Display the plot
        plt.show()

    def run_simulation(self, num_time_steps, display_progress=False):
        """
        Run the simulation starting from the center with the initial cell infected.

        Args:
            num_time_steps (int): Number of time steps to simulate.
            display_progress (boolean): Display or not progress
        """
        center_x = (self.size - 1) // 2
        center_y = (self.size - 1) // 2
        self.grid[center_x, center_y].state = CellStates.INFECTED
        self.plot()

        for i in range(num_time_steps):
            print("Iteration {} of {}. Total operating cost {}".format(i + 1, num_time_steps, self.total_cost))
            self.simulate(1)  # Simulate one time-step
            if display_progress:
                self.plot()

        self.plot()

    def __str__(self):
        return "\n".join(" ".join(map(str, row)) for row in self.grid)
