import numpy as np
import matplotlib.pyplot as plt

from Cell import Cell
from CellStates import CellStates


class Grid:
    """
    A class representing the grid of cells in the cellular automation model.
    """

    def __init__(self, size, parameters, costs, initial_fraction_infected=0.02, random_seed=None):
        """
        Initialize a Grid object with the given size and parameters.

        Args:
            size (int): The size of the grid (L).
            parameters (Parameters): An instance of the Parameters class containing model parameters.
            costs (Costs): An instance of the Costs class containing costs for cell states and transitions.
        """
        self.grid = None
        self.size = size
        self.parameters = parameters
        self.costs = costs
        self.total_cost = 0.0  # Initialize total operating cost
        self.initial_fraction_infected = initial_fraction_infected
        self.random_seed = random_seed

        # Set the random seed for reproducibility
        if random_seed is not None:
            np.random.seed(random_seed)

        self.initialize_grid()

    def initialize_grid(self):
        """
        Create a new grid
        """
        # Initialize the grid with cells
        self.grid = np.empty((self.size, self.size), dtype=Cell)

        # Set the initial states of cells
        for x in range(self.size):
            for y in range(self.size):
                # Randomly set initial state based on initial fraction of infected cells
                if np.random.rand() < self.initial_fraction_infected:
                    initial_state = CellStates.INFECTED
                else:
                    initial_state = CellStates.SUSCEPTIBLE
                self.grid[x, y] = Cell(initial_state)

    def get_neighbors(self, x, y):
        """
        Get neighboring cells of a given cell.

        Args:
            x (int): X-coordinate of the cell.
            y (int): Y-coordinate of the cell.

        Returns:
            list[Cell]: List of neighboring cells.
        """
        neighbors = []
        for dx in [-1, 0, 1]:
            for dy in [-1, 0, 1]:
                if dx == 0 and dy == 0:
                    continue
                new_x = (x + dx) % self.size
                new_y = (y + dy) % self.size
                neighbors.append(self.grid[new_x, new_y])
        return neighbors

    def simulate(self, num_time_steps, verbose=False, show_plot=False):
        """
        Simulate the SASIR model for the specified number of time steps and collect statistics.

        Args:
            num_time_steps (int): Number of time steps to simulate.
            verbose (boolean): Print or not progresses
            show_plot (boolean): Display or not the grid graphic
        """
        # Initialize total operating cost
        total_cost = 0.0

        # Initialize lists to store statistics over time steps
        infected_percentages = []
        vulnerable_percentages = []

        for time_step in range(num_time_steps):
            new_grid = self.grid.copy()

            # Counters for infected and vulnerable cells
            infected_count = 0
            vulnerable_count = 0

            for x in range(self.size):
                for y in range(self.size):
                    cell = self.grid[x, y]
                    cell_state = cell.state

                    # Get neighboring cell states
                    neighbors = self.get_neighbors(x, y)
                    neighbor_states = [neighbor.state for neighbor in neighbors]

                    # Apply transition to the cell and calculate cost
                    new_cell_state = cell.transition(neighbor_states, self.parameters)
                    # new_grid[x, y].state = new_cell_state

                    # Update counters based on new cell state
                    if new_cell_state == CellStates.INFECTED:
                        infected_count += 1
                    elif new_cell_state in [CellStates.SUSCEPTIBLE, CellStates.ALERT_A1, CellStates.ALERT_A2]:
                        vulnerable_count += 1

                    # Calculate the cost associated with the new state and transition
                    total_cost += self.costs.get_state_cost(new_cell_state)
                    try:
                        total_cost += self.costs.get_transition_cost(cell_state, new_cell_state)
                    except:
                        total_cost += 0.0  # There was no effective transition

            # Calculate percentages and store them
            total_cells = self.size * self.size
            infected_percentage = (infected_count / total_cells) * 100
            vulnerable_percentage = (vulnerable_count / total_cells) * 100

            infected_percentages.append(infected_percentage)
            vulnerable_percentages.append(vulnerable_percentage)

            self.grid = new_grid

            if verbose:
                print("Time Step {} - Infected: {:.1f}%, Vulnerable: {:.1f}% - Costs: {}".format(time_step,
                                                                                                 infected_percentage,
                                                                                                 vulnerable_percentage,
                                                                                                 total_cost))

            if show_plot:
                self.plot()

        return infected_percentages, vulnerable_percentages, total_cost

    def plot(self):
        """
        Plot the current state of the grid using a grid of squares with custom colors and borders.
        """
        state_colors = {
            CellStates.SUSCEPTIBLE: 'cyan',
            CellStates.ALERT_A1: 'yellow',
            CellStates.ALERT_A2: 'orange',
            CellStates.INFECTED: 'red',
            CellStates.RECOVERED: 'green'
        }

        # Create a new figure
        fig, ax = plt.subplots()

        # Plot each cell as a colored square with thick black border
        for x in range(self.size):
            for y in range(self.size):
                cell_state = self.grid[x, y].state
                cell_color = state_colors[cell_state]
                rect = plt.Rectangle((y, x), 1, 1, color=cell_color, edgecolor='black', linewidth=2)
                ax.add_patch(rect)

        # Customize plot appearance
        plt.title("SASIR Model Simulation")
        plt.xticks(range(self.size))
        plt.yticks(range(self.size))
        plt.gca().invert_yaxis()  # Invert y-axis to match array indexing

        # Add legend
        legend_labels = ['Susceptible', 'Alert (A1)', 'Alert (A2)', 'Infected', 'Recovered']
        legend_patches = [plt.Rectangle((0, 0), 1, 1, color=state_colors[i]) for i in range(len(legend_labels))]
        plt.legend(legend_patches, legend_labels, loc='upper right', bbox_to_anchor=(1, 1))

        # Display the plot
        plt.ion()
        plt.show()
        plt.pause(2)
        plt.close(fig)

    def __str__(self):
        return "\n".join(" ".join(map(str, row)) for row in self.grid)
